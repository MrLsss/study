# RabbitMq学习总结
## RabbitMq介绍

MQ全称为Message Queue，即消息队列， RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message
Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开
发中应用非常广泛。RabbitMQ官方地址：http://www.rabbitmq.com/

## 使用MQ的好处

### 实现异步处理

同步的通信：发出一个调用请求之后，在没有得到结果之前，就不返回。由调用者主动等待这个调用的结果。

异步通信：调用在发出之后，这个调用就直接返回了，所以没有返回结果。也就是说，当一个异步过程调用发出后，调用者不会马上得到结果。而是在调用发出后，

被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。

### 实现解耦

耦合是系统内部或者系统之间存在相互作用，相互影响和相互依赖。在我们的分布式系统中，一个业务流程涉及多个系统的时候，他们之间就会形成一个依赖关系。

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-1.png)

在传统的通信方式中，订单系统发生了退货的动作，那么要依次调用所有下游系统的 API，比如调用库存系统的 API 恢复库存，因为这张火车票还要释放出去给其他乘客购买；调用支付系统的 API，不论是支付宝微信还是银行卡，要把手续费扣掉以后，原路退回给消费者；调用通知系统 API 通知用户退货成功。

```java
// 伪代码 
public void returnGoods() { 
    stockService.updateInventory();
    payService.refund();
    noticeService.notice(); 
}
```

这个过程是串行执行的，如果在恢复库存的时候发生了异常，那么后面的代码都不会执行。由于这一系列的动作，恢复库存，资金退还，发送通知，本质上没有一个严格的先后顺序，也没有直接的依赖关系，也就是说，只要用户提交了退货的请求，后面的这些动作都是要完成的。库存有没有恢复成功，不影响资金的退还和发送通知。

使用MQ

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-2.png)

订单系统只需要把退货的消息发送到消息队列上，由各个下游的业务系统自己创建队列，然后监听队列消费消息。

在这种情况下订单系统里面就不需要配置其他系统的 IP、端口、接口地址了，因为它不需要关心消费者在网络上的什么位置，所以下游系统改 IP 没有任何影响。

甚至不需要关心消费者有没有消费成功，它只需要把消费发到消息队列的服务器上就可以了。这样，我们就实现了系统之间依赖关系的解耦。

### 实现流量削峰

在很多的电商系统里面，有一个瞬间流量达到峰值的情况，比如京东的 618，淘宝的双 11。普通的硬件服务器肯定支撑不了这种百万或者千万级别的并发量，就像 2012 年的小米一样，动不动服务器就崩溃。如果通过堆硬件的方式去解决，那么在流量峰值过去以后就会出现巨大的资源浪费。那要怎么办呢？如果说要保护我们的应用服务器和数据库，限流也是可以的，但是这样又会导致订单的丢失，没有达到我们的目的。

引入MQ，MQ是队列，一定有队列的特性，(先进先出)就可以先把所有的流量承接下来，转换成 MQ 消息发送到消息队列服务器上，业务层就可以根据自己的消费速率去处理这些消息，

处理之后再返回结果。就像我们在火车站排队一样，大家只能一个一个买票，不会因为人多就导致售票员忙不过来。如果要处理快一点，大不了多开几个窗口（增加几个消费者）。

### 总结

- 对于数据量大或者处理耗时长的操作，我们可以引入 MQ 实现异步通信，减少客户端的等待，提升响应速度。

- 对于改动影响大的系统之间，可以引入 MQ 实现解耦，减少系统之间的直接依赖。

- 对于会出现瞬间的流量峰值的系统，我们可以引入 MQ 实现流量削峰，达到保护应用和数据库的目的。

## RabbitMq中的模型概念

MQ的本质：消息队列，又叫做消息中间件。是指用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型， 可以在分布式环境下扩展进程的通信

###  MQ的特点

1. 是一个独立运行的服务。生产者发送消息，消费者接收消费，需要先跟服务器建立连接。
2. 采用队列作为数据结构，有先进先出的特点。
3. 具有发布订阅的模型，消费者可以获取自己需要的消息。

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-3.png)



### 消息模型

所有 MQ 产品从模型抽象上来说都是一样的过程：消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-4.png)

### RabbitMq的基本概念

下图是RabbitMQ的基本结构：

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-5.png)

#### 组成部分说明

- Broker：消息队列服务，此进程包括两个部分：Exchange和Queue。
- Exchange：消息队列交换机，按一定的规则将消息路由转发到某个队列，对消息进行过虑。队列使用绑定键（Binding Key）跟交换机建立绑定关系。
- Queue：消息队列，存储消息的队列，消息到达队列并转发给指定的消费方，它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。
- Binding：绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。
- Routing Key：路由关键字，Exchange根据这个关键字进行消息投递
- Virtual Host：虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。
- Message：消息，消息是不具名，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括**routing-key**（路由键）、**priority**（相对于其他消息的优先权）、**delivery-mode**（指出该消息可能需要持久性存储）等。
- Producer：消息生产者，即生产方客户端，生产方客户端将消息发送到MQ。
- Consumer：消息消费者，即消费方客户端，接收MQ转发的消息。
- Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。
- Connection：无论是生产者发送消息，还是消费者接收消息，都必须跟Broker之间建立一个连接，这个是TCP长连接

#### 相关名词

![](https://my-study-notes.oss-cn-beijing.aliyuncs.com/RabbitMq/RabbitMq%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93-6.jpg)包括：ConnectionFactory（连接管理器）、Channel（信道）、Exchange（交换器）、Queue（队列）、RoutingKey（路由键）、BindingKey（绑定键）。

- **ConnectionFactory**（连接管理器）：应用程序与Rabbit之间建立连接的管理器，程序代码中使用；

- **Channel**（信道）：消息推送使用的通道；

- **Exchange**（交换器）：用于接受、分配消息；

- **Queue**（队列）：用于存储生产者的消息；

- **RoutingKey**（路由键）：用于把生成者的数据分配到交换器上；

- **BindingKey**（绑定键）：用于把交换器的消息绑定到队列上；

## 消息发布接收流程
### 发送消息

1. 生产者和Broker建立TCP连接。
2. 生产者和Broker建立通道。
3. 生产者通过通道消息发送给Broker，由Exchange将消息进行转发。
4. Exchange将消息转发到指定的Queue（队列）

### 接收消息

1. 消费者和Broker建立TCP连接
2. 消费者和Broker建立通道
3. 消费者监听指定的Queue（队列）
4. 当有消息到达Queue时Broker默认将消息推送给消费者。
5. 消费者接收到消息。

> 参考链接：https://www.cnblogs.com/Jeely/p/12388913.html