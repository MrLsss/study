# MySQL索引总结

# 索引的目的
> 提高查询效率

类比字典，例如要查找“引”这个字，可以通过字典的拼音或者偏旁部首去查询。如果没有这些，那么就需要把字典从头翻到尾的这种方式，才能找到这个字。
# 索引的原理
> 通过不断的缩小想要获得数据的范围来筛选出最终的结果，同时把随机的事件变成顺序的事件（有了这种索引机制，我们总是能够通过同一种查找方式来锁定数据）

数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段……这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。
## 磁盘IO
磁盘读取数据靠的是机械运动，每次读取数据所花费的时间可以分为：寻道时间、旋转延迟和传输时间。

1. 寻道时间：指MO磁光盘机（magneto-optical disk，即磁光盘的意思）在接收到系统指令后，磁头从开始移动到移动到数据所在磁道所需要的平均时间。主流磁盘一般在5ms以下。
1. 旋转延迟：从磁盘寻道结束开始，直到磁头旋转到IO所请求的数据块位置为止，这之间的时间间隔称为旋转延迟。一般都将磁盘旋转周期的一半定义为旋转延迟。比如一个7200转的磁盘，表示每分钟转7200次，也就是1秒钟能转120次，所以旋转延迟就是1/120/2=4.17ms。
1. 传输时间：从磁盘读出或将数据写入磁盘的时间，一般零点几毫秒，想对于前两者的时候可以忽略不计。

那么一次磁盘IO的时间约为9ms左右。
### MIPS
机器都是通过指令去执行相关的操作，机器执行指令的效率就显得尤为重要。
MIPS：每秒处理的百万级的机器语言指令数。是衡量CPU速度的一个指标。
比如：500-MIPS，就是该机器每秒可执行5亿条指令。
而真正执行一条指令CPU会经历取指、译码、执行、回写等过程，所以每秒执行的指令数量还会有折扣。换句话说，执行一次IO的时间可以执行约40万条执行。而如果是对面百万千万级别的数据，每次光IO就要花费9m的时间，显然是不行的。
## 预读
因为磁盘IO是一个非常高昂的操作，计算机操作系统做了一些优化，当一次IO时，不光是把当前磁盘地址的数据读取出来，还把相邻的数据也都读取到内存缓冲区内。每一次IO读取的数据，称为一页（page）。具体一页有多大的数据一把和操作系统有关，一般是4k或8k。也就是说我们读取一页数据的时候，实际上才发生一次IO。
# 索引的数据结构
> 要优化数据库查找，就要把每次查找数据时把磁盘IO控制在一个很小的数量级，最好是常数量级别的。

## B树
> B树又叫多路平衡查找树

### 特性
一颗m叉的B树，其特性如下：

- 树中每个节点最多包含m个孩子
- 除根节点和叶子节点外，每个节点至少有 `m/2` 个孩子（向上取整）
- 如果根节点不是叶子节点，则至少有两个孩子
- 所有的叶子节点都在同一层
- 每个非叶子节点由n个key和n+1个指针组成（m/2-1 <= n <= m-1）
### 结构图
3叉的B-Tree结构图
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-1.png)
每个大方框是一个磁盘块，这是操作系统一次IO向内存读的数据，一个块对应四个扇区，p代表指针，指向下一个磁盘块的位置（p1代表小于17的磁盘块，p2代表在17和35之间的磁盘块，p3代表大于35的磁盘块），数字代表磁盘块中数据的key，data代表数据。

### 查找
必须从根节点开始查找，一般采用二分法。
### 模拟
模拟查找key为29的data的过程：

1. 根据根节点指针读取文件目录的根磁盘块1（IO一次）
1. 发现17<29<35，因此找到指针p2
1. 根据p2指针，定位并读取磁盘块3（IO一次）
1. 发现26<29<30，因此找到指针p2
1. 根据p2指针，定位并读取磁盘块8（IO一次）
1. 磁盘块8中存储了25和29，因此找到了29对应的数据data

由此可见，B-Tree索引使得每次的磁盘IO读取到内存中的数据都起到了作用，从而提高了查询效率
### 缺陷
从上图可知，每个节点中，不仅包含了数据的key值，还包含了data值。而因为每页的存储空间是有限的，如果data过大时，会导致每个节点能存储的key值的数量变小。所以当数据量很大时会导致B-Tree的深度增加，进而增加磁盘IO的次数，最终影响到查询效率。
## B+树
> B+Tree是在B-Tree基础上的一种优化，在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储数据的key值，这样设计大大增加了每个节点存储的key值数量，降低了B+Tree的高度。

### 结构图
假设每个节点只能存储4个键值和指针信息
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-2.png)

- 所有的叶子节点之间是一种链式环结构
  - 因此可以进行主键的范围查找和分页查找
- 通常B+Tree上有两个头指针，一个指向根节点，一个指向关键字最小的叶子节点
  - 因此可以进行随机查找

在InnoDB存储引擎中，页的大小为16kb，一般表的主键类型为int（4个字节）或bigint（8个字节），指针类型也一般为4或8个字节，也就是说一页（一个节点）中大概存储了 `16kb/(8b+8b)=1k` 个键值，也就是一个高度为3的B+Tree可以维护1000*1000*1000=10亿条记录。（第一层存储1000个key，每个key又有1000个子key，那么第二层就有1000*1000个key，第二层的每个key有1000个key，那么第三层就有1000*1000*1000个）
而实际情况每个节点可能不能填满，因此在数据库中，B+Tree的高度一般在2-4层。MySQL的InnoDB引擎在设计时，是让根节点常驻内存，也就是说查找某个键值的记录时，最多只需要进行1-3次IO

### 性质（重点）

1. 通过以上知道，IO次数取决于B+Tree的高度，假设当前数据表的数据为N项，每个磁盘块的数据项的数量是M，则有 `h=log(M+1)N` ，当数据量N在一定的情况下，M越大，h越小，而磁盘块的大小是固定的，所以 `M=磁盘块的大小/数据项的大小` ，如果数据项所占空间越小，则树的高度越低。这就是为什么每个数据项，即索引字段要尽量小，比如int（4字节）和bigint（8字节），就差了一半的大小。这也是为什么B+Tree要求把真实数据放到叶子节点而不是内层节点，一旦放到内层节点，每个磁盘块的数据项量会大幅度下降，导致树增高。当数据项等于1时，会退化成一个线性表。
1. 当B+Tree的数据项是复合的数据结构时，比如（name+sex+age）的时候，B+Tree是按照从左向右的顺序来建立搜索树的，比如当（张三，1，20）这样的数据来检索时，B+Tree会先比较name来确定下一步的搜索方向，如果name相同再去依次比较sex和age，最后得到检索的数据；但是当（1，20）这样的数据来检索，就无法比较name，B+Tree就不知道下一步该查哪个节点。因此建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当（张三，20）这样的数据来检索时，B+Tree可以用name来指定搜索方向，但是sex字段缺失，所以就只能把name=张三的所有数据都找到，然后再匹配age=20的数据了。这就是**最左匹配原则**。
### 与B-Tree的区别

- B+Tree关键字的搜索采用的左闭右开的区间。是因为最好的去支持自增ID，如果id=1命中，会继续往下查找，直到找到叶子节点中的1。
- B+Tree的根节点和叶子节点没有数据区（data），只保存关键字和子节点的引用，关键字对应的数据只保存在叶子节点中。只有叶子节点中的关键字才会保存真正的数据内容或内容地址。而在B-Tree中，如果根节点命中了数据，则会直接返回数据。
- 在B+Tree中，叶子节点是顺序排序的，并且相邻的节点具有顺序引用的关系，有指针相连接。
### MySQL为什么选择B+Tree

- B+Tree是B-Tree的变种，B-Tree能解决的B+Tree也能解决
- B+Tree扫库和扫表能力更强。如果要根据索引去进行数据表的扫描，对于B-Tree，需要把整棵树遍历一遍（因为B-Tree内层节点也存储了数据），而B+Tree只需要遍历他所有的叶子节点即可（叶子节点之间有引用）。
- B+Tree磁盘读取的能力更强，因为他的根节点和内层节点不保存数据区，所以根节点和内层节点在同样大的情况下，保存的关键字要比B-Tree多，而叶子节点不保存子节点的引用，能用于保存更多的关键字和数据。所以B+Tree读写一次磁盘加载的关键字要比B-Tree更多。
- B+Tree排序能力更强
- B+Tree查询性能更稳定，每次查询IO次数一定是稳定的。查询性能不一定更强，因为B-Tree如果在根节点就命中了数据就会直接返回。



# B+Tree在MySQL具体实现形式
## Myisam引擎
Myisam存储引擎存储数据库数据，一共有三个文件：

1. .Frm文件：表的定义文件
1. .MYD文件：数据文件，所有的数据保存在这个文件中
1. MYI文件：索引文件

### Myisam聚集索引
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-3.png)
如上所示，两个文件分别保存了数据和索引，由于在B+Tree中只有叶子节点有数据区，在Myisam中，数据区中保存的是数据的引用地址。
比如查询id为101的数据。当查找到键为101的这个叶子节点时，可以读取到这条数据的物理磁盘地址：0x123456，就可以通过这个磁盘指针将数据数据加载出来。


### Myisam辅助索引
如果不用ID作为索引，改用name作为索引
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-4.png)
和聚集索引一样，叶子节点也是保存的该记录的磁盘物理地址，**他们是平级的**

## InnoBD引擎
InnoDB存储引擎存储数据数据，一共有两个文件：

1. .Frm文件：表的定义文件
1. .ibd文件：数据和索引存储文件。数据以主键进行聚集存储，把真正的数据保存在叶子节点中。



### InnoDB辅助索引
在InnoDB中，因为设计之初就认为主键是非常重要的。是以主键为索引来组织数据的存储，当我们没有显式的建立主键索引的时候，搜索引擎会隐式的帮我们建立一个主键索引以组织数据存储。
数据表行中数据的物理顺序与键值逻辑（索引）顺序相同，InnoDB就是以聚集索引来组织数据的存储的，在叶子节点上，保存了数据的所有信息。如果这个建立name字段的索引
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-5.png)
会产生一个辅助索引，name字段的索引，而此时辅助索引的叶子节点上保存的数据为聚集索引（ID索引）的关键字的值。基于辅助索引找到ID索引的值，再通过ID索引去获取最终的数据。


### InnoDB与Myisam比较
**Myisam**：

- 不支持事务，而且不支持外键，但是每次查询都是原子的
- 支持表级锁，即每次操作是对整个表加锁
- 一个Myisam表有三个文件：索引文件、表结构文件、数据文件
- 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅助索引与聚集索引基本一致，但是辅助索引不用保证唯一性

优点：查询数据相对较快，适合大量的select，可以全文索引
缺点：不支持事务，不支持外键，并发量小，不适合大量的update


**InnoDB**：

- 支持ACID的事务，支持事务的四种隔离级别
- 支持行级锁及外键约束：因此可以支持写并发
- 不存储总行数
- 一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立的表空间，表大小受操作系统文件大小限制，一般为2G）
- 主键索引采用聚集索引（索引的数据域存储数据文件本身），辅助索引的数据域存储主键的值；因此从辅助索引查找数据，需要先通过辅助索引找到主键值，再访问辅助索引；最好使用自增主键，防止插入数据时，为维持B+数据结构，文件的大调整。

有点：支持事务，支持外键，并发量大，适合大量的update
缺点：查询数据相对较快，不适合大量的select
# 索引相关优化

- 建立索引的列离散性要高（ `count(distinct col):count(col)` ）：离散性越高越好。假设给性别列（男：1，女：0）建立索引，就会生成以下的索引树

![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-6.png)

- 最左匹配原则：对索引中关键字进行计算（对比），是从左向右依次进行的，并且不可跳过

![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93/MySQL%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93-7.png)
如果id为字符串时，当进行匹配的时候，会把字符创转成ASCII码，abc会变成97、98、99，然后从左向右一个一个字符的对比。所以在sql查询中用 `like %a` 时索引会失效，是因为 `%` 标识全部匹配，既然已经全部匹配了，还要索引干啥，好不如全表扫描。

- 最少空间原则：创建索引的关键字尽可能占用空间要小
- 联合索引
  - 单列索引：节点中的关键字[name]
  - 联合索引：节点中的关键字[name,sex,age]
- 覆盖查询：如果查询的列，通过索引的信息可直接返回，则该索引称为查询SQL的覆盖查询，覆盖查询可以提高效率

例如上面的name和id，如果通过name查询 `select * from user where name = xxx` ，这就需要现在辅助索引（name索引）中查到id，再去聚集索引中通过id查到对应的数据。整个过程经历了两个扫描索引。
如果现在只需要查询id，改写成 `select id from user where name = xxx` ，在扫描辅助索引后，就能拿到id的值，就不需要去扫描聚集索引了。
这也就是为什么少用 `select *` 的原因之一，如果所有列过多，会增加网络传输量。但是返回所有字段通用性会更强，视情况而用。

- 索引列不能参与计算，保持列干净。比如： `to_date(time) = '2020-01-01'` 就不能用到索引，B+Tree中存的都是数据表中的字段值，当时进行检索时，需要把所有的元素都应用到函数上才能生效，显然成本过大，应该改写成 `time = to_date(2020-01-01)`
- 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。



# 索引的使用条件

1. 对于非常小的表，大部分情况下简单的全表扫描比建立索引更加高效
1. 对于中到大型的表，索引就非常有效
1. 对于特大型的表，建立和维护索引的代价就会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录的匹配，例如可以使用分区技术

_为什么对于非常小的表，大部分情况下简单的全表扫描比建立索引更加高效？_
如果一个表比较小，那么显然直接遍历表要比走索引更快（因为需要**回表**）


# MySQL中的索引类型

- 普通索引
- 唯一索引（unique）
  - 索引列的值必须唯一，允许有空值。如果是组合索引，则列值的组合必须唯一
- 主键索引
  - 一般建表的时候，自动给主键建立索引
- 组合索引
- 全文索引（fulltext）
  - 只有char、varchar、text类型上才可以创建全文索引
# 查询优化
## explain分析查询语句

- select_type：查询类型
  - SIMPLE：简单的select，不使用UNION或子查询等
  - PRIMARY：查询中若包含任何复杂的子部分，最外层的select被标记为PRIMARY
  - UNION：如果第二个select出现在UNION之后，则被标记为UNION，如果UNION包含在from子句的子查询中，外层的select被标记为derived
  - SUBQUERY：在select或where列表中包含了子查询
  - UNION RESULT：UNION的结果，UNION语句中第二个select开始后面所有select
- table：显示这一步所访问数据库中表名称（显示这一行的数据是关于哪张表的），有时不是真实的表名字，可能是表的简称，也可能是第几步执行的结果的简称
- type：对表访问方式，标识MySQL在表中找到所需行的方式，又称“访问类型”
  - ALL：Full Table Scan，MySQL将遍历全表以找到匹配的行
  - index：Full Index Scan，index与ALL区别为index类型只遍历索引树
  - range：只检索给定范围的行，使用一个索引来选择行
  - ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
  - eq_ref：类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说就是多表连接中使用primary key或者unique key作为关联条件
  - const、system：当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量，system是const类型的特例，当查询的表只有一行的情况下，使用system
  - NULL：MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。

ALL、index、range、ref、eq_ref、const、system、NULL（从左到右，性能从差到好）

- possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定会使用
- key：显示MySQL实际决定使用的键（索引），必然包含找possible_keys中
- key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度（key_len显示的值为索引字段的最大可能长度，并非实际使用长度）
- ref：列与索引的比较，表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值
- rows：估算出结果集行数，表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数
