# MySQL如何执行一条语句

# MySQL如何执行一条查询语句
> MySQL是如何执行一条SQL语句的？
> 例如：`select * from T where id = 1` 



# MySQL基本架构
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5/MySQL%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5-1.png)
大体上来说，MySQL可以分为Server层和存储引擎层两部分

## Server层
Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
## 存储引擎层
存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、Myisam、Memory等多个存储引擎。


通过上图可以看出，**不同的存储引擎共用一个Server层**


# Server层各个组件
## 连接器
> 首先，要使用一个数据库，就必须先要连接到这个数据库，这个时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接

### 建立连接
一般连接命令的写法： `mysql -h$ip -P$port -u$user -p`
在输入完命令之后，就需要在输入密码。（虽然密码也可以写在-p后面，但是这样写会暴露密码）
连接命中的MySQL是客户端工具，用来跟服务端建立连接。建立连接之后，连接器就要开始认证身份，这个时候用到的就是输入的用户名和密码。

- 如果用户名或密码不正确，就会收到一个 `Access denied for user` 的错误，然后客户端程序结束执行
- 如果用户名密码认证通过，连接器就会到权限表里面查出当前登录用户所拥有的权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限

这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完后，只有再建立的连接才会使用新的权限设置。
### 空闲连接
连接完成后，如果你没有后续的动作，这个连接就会处于空闲状态，可以输入 `show processlist` 命令查看到它。
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5/MySQL%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5-2.png)
上图就是 `show processlist` 的结果，其中Command列显示的“sleep”的这一行，表示系统中的空闲连接。
客户端如果太长时间没有动静，连接器就会自动将它断开。这个时间是由参数 `wait_timeout` 控制的，默认是8小时。
如果在连接被断开之后，客户端再次发起请求，就会收到 `Lost connection to MySQL server during query` 的错误提醒，这个时候如果要继续，就需要重连，然后再执行请求。

### 长连接和短连接
长连接：如果客户端持续有请求，则一直使用同一个连接
短连接：每次执行完很少的几次查询就断开连接，下次查询再重新建立一个
建立连接的过程是比较复杂的，所以在使用中尽量使用长连接。但是全部使用长连接后，会发现有时候MySQL占用内存涨得特别快，这是因为MySQL在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉，从现象来看就是MySQL异常重启了。
解决方案：

1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存大的查询后，断开连接，之后要查询再重连
1. 如果是MySQL5.7或更高版本，可以在每次执行一个比较大的操作后，通过执行 `mysql_reset_connection` 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。
## 查询缓存
> 连接建立完成后，就可以执行select语句了。执行逻辑就到第二步：查询缓存

MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。

- 如果查询语句能够直接在这个缓存中找到key，那么这个value就会被直接返回给客户端。
- 如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。

可以看到查询命中缓存，就不会去执行后面的操作，直接返回结果，可以大大的提高效率
### 弊端
查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能很费劲的把结果存起来，还没使用，就被一个更新操作清空了。对于频繁更新的数据库来说，查询缓存的命中率会非常低。除非业务就是一张静态表，很长时间才更新一次，那这张表上的查询才适合使用查询缓存（例如系统的配置表等）。


MySQL也提供了“按需使用”的方式，可以将参数 `query_cache_type` 设置为 `DEMAND` ，这样对于默认的SQL语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以使用 `SQL_CACHE` 现实的指定，例如： `select SQL_CACHE * from T where id = 1`
_MySQL8.0版本将查询缓存功能删除了_
_
## 分析器
> 如果没有命中查询缓存，就要开始真正执行语句了。首先，MySQL需要知道你想要做什么，所以需要对SQL语句解析

`select * from T where id = 1`
### 词法分析
一条SQL语句是由多个字符串和空格组成的，MySQL需要是被出里面的字符串分别是什么，代表什么
MySQL从输入的“select”这个关键字识别出来，这是一个查询语句。也要把字符串“T”识别成“表名T”，把字符创“id”识别成“列id”。
### 语法分析
当做完吃法分析后，就要开始做语法分析。
根据词法分析的结果，语法分析器会根据语法规则，判断输入的SQL语句是否满足MySQL语法。
如果输入的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒，例如：
```sql
elect * from T where id = 1 -- select少了“s”
ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'elect * from t where id=1' at line 1
```
一般语法错误会提示第一个出现错误的位置，所以要关注的是紧接“user near”的内容


## 优化器
> 经过分析器，MySQL已经知道这条SQL语句要做什么。在开始执行之前，还要先经过优化器的处理。

优化器是在表里面有多个索引的时候，决定使用哪个索引。或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。例如：
```sql
select * from t1 join t2 on t1.id = t2.id where t1.c=10 and t2.d=20;
等价于
select * from t1 join t2 using(id)  where t1.c=10 and t2.d=20;
```

- 可以先从表t1里面取出c=10的记录的id值，再根据id值关联到表t2，再判断t2里面d的值是否等于20
- 也可以先从表t2里面取出d=20的记录的id值，再根据id值关联到t1，再判断t1里面c的值是否等于10

这两种执行方法的逻辑结果是一样的，但是执行效率会有不同，而优化器的作用就是决定选择使用哪一种方法
优化器阶段完成后，这个语句的执行方案就确定下来，然后进入执行器阶段


## 执行器
> MySQL通过分析器知道了要做什么，通过优化器知道了该怎么做，于是就进入到执行器阶段，开始执行语句。

在开始执行的时候，要先判断一下当前用户对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下：
```sql
select * from T where id = 1；

ERROR 1142 (42000): SELECT command denied to user 'b'@'localhost' for table 'T'
```
如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
比如该例子中的表T，id字段没有索引，那么执行器的执行流程是这样的：

1. 调用InnoDB引擎接口取这个表的第一行，判断id的值是不是10，如果不是则跳过，如果是则 将这行记录存在结果集中；
1. 调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。
1. 执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。

至此，这个语句就执行完成了。
对于有索引的表，执行逻辑类似。第一次调用的是 “取满足条件的第一行”这个接口，之后循环调用“满足条件的下一行”这个接口。
可以在数据库的慢查询日志中看到一个“rows_examined”的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。


# MySQL如何执行一条更新语句
> `create table T(id int primary key, c int);`
> `update T set c = c+1 where id = 2` 

查询语句的那一套流程，更新语句也会走一遍


## 与查询语句的异同
执行语句前要先连接数据库，这是连接器的工作。
前面说过，在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表T上所有的查询缓存结果都清空。这也就是一般不建议使用查询缓存的原因。
接下来，分析器会通过词法和语法分解析知道这是一条更新语句。优化器决定要使用id这个索引。然后，执行器负责具体执行，找到这一行，执行更新。
与查询流程不一样的是，更新流程还涉及到两个重要日志模块： `redo log（重做日志）` 和 `binlog（归档日志）` 。


## redo log（物理日志）
> 如果每一次更新操作都需要写进磁盘，然后磁盘要找到对应的那条记录，然后再更新，整个过程IO成本、查找成本都很高。

### WAL——Write-Ahead Loggin
关键点在于：先写日志，再写磁盘
当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log里面，并更新内存，这个时候更新就算完成了。同时InnoDB引擎会在系统比较空闲的时候，将这个操作记录更新到磁盘里面去。
InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么这个redo log总共就可以记录4GB的操作。从头开始写，写到末尾就又回到开头循环写，如下：
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5/MySQL%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5-3.png)
write pos是当前记录的位置，一边写一边后移，写到3号文件末尾后就回到0号文件开头。
check point是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。


write pos和check point之间是空着的文件，可以用来记录新的操作。如果write pos追上check point，则表示文件已满，这时候不能再执行新的更新，要先停下来擦除一些记录，把check point往前推进以下。
### crash-safe
有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe。**
## binlog（逻辑日志）
MySQL从整体来看，一共有两层，一层是Server层，它主要做的是MySQL功能层面的事情；还有一层是引擎层，负责存储相关的事情。redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）
### 与redo log的不同

1. redo log是InnoDB特有的；binlog是MySQL的Server成实现的，所有引擎都可以使用
1. redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2这一行的c字段加1”
1. redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



## 执行器和InnoDB执行update的内部流程

1. 执行器先找引擎取id=2这一行。id是主键，InnoDB直接用树搜索找到这一行。如果id=2这一行所在的数据页本来就在内存中，就直接返回给执行器；否则需要从磁盘读入内存，然后再返回。
1. 执行器拿到引擎给的行数据，把这个值加上1，例如原来是N，现在就是N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
1. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到redo log中，此时redo log处于 `prepare` 状态。然后告知执行器执行完了，随时可以提交事务。
1. 执行器生成这个操作的binlog，并把binlog写入磁盘。
1. 执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log 改成提交（commit）状态，更新完成。

浅色：在InnoDB内部执行，深色：在执行器中执行
![image.png](https://my-study-notes.oss-cn-beijing.aliyuncs.com/sql/MySql%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5/MySQL%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E4%B8%80%E6%9D%A1%E8%AF%AD%E5%8F%A5-4.png)
最后的redo log的写入拆为两个步骤：prepare和commit，这就是“两阶段提交”


## 两阶段提交
> 是为了让两份日志之间的逻辑保持一致

### 为什么需要两阶段提交
首先由于redo log和binlog是两个独立的逻辑，如果不用两阶段提交，要么就是先写完redo log再写binlog，或者顺讯反过来。这样会出现什么问题？
`update T set c = c+1 where id = 2`
假设当前id=2的行，字段c的值是0，并且假设执行update过程中在写完第一个日志后，第二个日志还没写完期间发生了crash。

1. **先写redo log，再写binlog。**假设在redo log写完，binlog还有写完的时候，MySQL进程异常重启。redo log写完之后，即使系统崩溃，仍然能够把数据恢复回来，所以恢复后这一行c的值是1。但是由于binlog还没写完就crash了，这时候binlog里面就没有记录这个语句。如果需要用这个binlog来恢复的话，由于这个语句的binlog丢失，这个临时库就会少了这一次更新，恢复出来的这一行c的值就是0，与原库的值不同。
1. **先写完binlog，再写redo log**。如果在binlog写完之后crash，由于redo log还没写完，崩溃恢复以后这个事务无效。所以这一行c的值是0.但是binlog里面已经记录了“把c从0改成1”这个日志。所以，在之后用binlog来恢复的时候就多了一个事务，恢复出来的这一行c的值是1，与原库不同。

如果不使用“两阶段提交”，那么数据库的状态就可能和用它的日志恢复出来的库的状态不一致。
简单说，redo log和binlog都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。


